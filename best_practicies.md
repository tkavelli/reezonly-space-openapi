# Архитектура документации API нового поколения

## Стратегия внедрения OpenAPI 3.1 и Redocly

### Введение

В современной экосистеме разработки программного обеспечения документация API перестала быть второстепенным артефактом, создаваемым постфактум. Она трансформировалась в критически важный компонент продукта, определяющий Developer Experience (DX) и скорость интеграции.¹

Переход индустрии к спецификации OpenAPI 3.1 в сочетании с инструментарием Redocly открывает беспрецедентные возможности для создания модульной, валидируемой и визуально совершенной документации. Однако реализация этого потенциала требует отказа от монолитных подходов в пользу строго структурированной, доменно-ориентированной архитектуры файлов.

### О документе

Данный отчет представляет собой исчерпывающее руководство по проектированию, разработке и поддержке документации API «лучшего в классе» (best-in-class).

**Мы детально разберем:**
- Методологию разделения спецификаций на модульные YAML-файлы
- Использование продвинутых возможностей OpenAPI 3.1 (таких как дискриминаторы и вебхуки)
- Тонкую настройку рендеринга через `redocly.yaml` и вендорные расширения (`x-tagGroups`, `x-codeSamples`)
- Практическую реализацию трех разнородных методов API, демонстрирующих работу с вложенностью, полиморфизмом и группировкой

---

## Часть I: Эволюция стандартов и инструментария

### 1.1 Смена парадигмы: От Swagger к OpenAPI 3.1

Переход от OpenAPI 3.0 к версии 3.1 знаменует собой фундаментальный сдвиг в способах описания контрактов данных. Если версия 3.0 опиралась на устаревший Draft 5 JSON Schema, то версия 3.1 обеспечивает полную совместимость с актуальным JSON Schema Draft 2020-12.¹ Для технического писателя и архитектора API это означает появление мощных инструментов выразительности, которые Redocly способен визуализировать «из коробки».

#### Ключевые изменения, влияющие на стратегию документирования:

**Типизация массивов и Nullable:** В OAS 3.0 использование `nullable: true` часто вызывало конфликты в генераторах кода и неоднозначность в документации. OAS 3.1 позволяет определять типы как массивы, например, `type: ["string", "null"]`. Redocly рендерит это как явное указание на допустимость отсутствия значения, что снижает когнитивную нагрузку на потребителя API.⁷

**Вебхуки как граждане первого класса:** Ранее асинхронные события (callbacks) описывались внутри операций. Теперь поле `webhooks` находится на верхнем уровне спецификации, что позволяет Redocly отображать их в боковом меню наравне с синхронными HTTP-методами, создавая целостную картину возможностей интеграции.⁹

**Улучшенный полиморфизм:** Конструкции `oneOf`, `anyOf` и `allOf` теперь работают более предсказуемо благодаря строгому соответствию JSON Schema. Визуализация дискриминаторов в Redocly позволяет пользователю динамически переключать формы запросов и ответов, что критически важно для сложных доменных моделей.¹⁰

---

### 1.2 Экосистема Redocly: За пределами рендеринга

При выборе инструментария важно понимать, что Redocly — это не просто библиотека для рендеринга (Redoc), но и мощный CLI для управления жизненным циклом API.¹ Подход **"Docs-as-Code"** (документация как код) требует использования CLI для линтинга, разделения (split) и сборки (bundle) файлов.

Использование Redocly CLI позволяет реализовать модульный подход, при котором единый файл `openapi.yaml` служит лишь точкой входа (entrypoint), а вся содержательная часть разнесена по сотням мелких файлов. Это решает проблему конфликтов слияния (merge conflicts) в системах контроля версий и позволяет разным командам работать над разными доменами API параллельно.¹²

#### Сравнение Swagger UI и Redocly:

| Характеристика | Swagger UI | Redocly (Redoc) |
|---|---|---|
| **Макет** | Одностраничный, вертикальный стек | Трехпанельный (Навигация, Описание, Примеры)² |
| **Навигация** | Простая группировка по тегам | Многоуровневая вложенность через `x-tagGroups`³ |
| **Примеры кода** | Генерируемые, ограниченные | Кастомизируемые через `x-codeSamples`, поддержка внешних файлов¹⁵ |
| **Производительность** | Падает на больших спецификациях | Оптимизирован для спецификаций в 50k+ строк¹² |

---

## Часть II: Архитектура файловой системы и модульность

Для создания «наилучшей» документации критически важно правильно организовать файловую структуру. Плоская структура, где все пути лежат в одной папке, становится неуправляемой при масштабировании. Рекомендуется использовать **Доменно-Ориентированную Структуру (Domain-Driven Directory Structure)**, которая отражает бизнес-логику вашего приложения.²

### 2.1 Стратегия разделения файлов (Splitting Strategy)

Согласно лучшим практикам Redocly, корневой файл должен содержать минимум информации: метаданные, настройки серверов, глобальные теги и ссылки на пути (paths). Все остальное должно быть вынесено в директории `paths/` и `components/`.¹²

Использование команды `redocly split` позволяет автоматически разбить монолитный файл, но для достижения идеального результата часто требуется ручная реорганизация папок по доменам.

#### Рекомендуемая структура проекта:

```
/api-docs-root
├── redocly.yaml                # Главный конфигурационный файл
├── openapi.yaml                # Корневой файл спецификации (Entrypoint)
├── components/                 # Переиспользуемые компоненты
│   ├── schemas/                # Модели данных (Schemas)
│   │   ├── Identity/           # Домен идентификации
│   │   │   ├── User.yaml
│   │   │   ├── UserProfile.yaml
│   │   │   └── AuthToken.yaml
│   │   ├── Commerce/           # Домен коммерции
│   │   │   ├── Order.yaml
│   │   │   ├── PaymentMethod.yaml
│   │   │   └── Invoice.yaml
│   │   └── Shared/             # Общие типы
│   │       ├── Error.yaml
│   │       └── UUID.yaml
│   ├── responses/              # Стандартные ответы (400, 401, 404)
│   ├── parameters/             # Общие параметры (пагинация, сортировка)
│   ├── examples/               # Примеры JSON тел запросов/ответов
│   └── securitySchemes/        # Определения безопасности (OAuth2, API Key)
├── paths/                      # Описания эндпоинтов
│   ├── Identity/               # Папка домена Identity
│   │   ├── Users/              # Ресурс Users
│   │   │   ├── CreateUser.yaml # POST /users
│   │   │   ├── GetUser.yaml    # GET /users/{id}
│   │   │   └── ListUsers.yaml  # GET /users
│   │   └── Auth/
│   │       └── Login.yaml
│   ├── Commerce/               # Папка домена Commerce
│   │   ├── Orders/
│   │   │   └── PlaceOrder.yaml
│   │   └── Payments/
│   │       └── ProcessPayment.yaml
│   └── Reporting/              # Папка домена Reporting
│       └── Financial/
│           └── AnnualReport.yaml
└── code_samples/               # Внешние файлы с примерами кода
    ├── python/
    └── java/
```

Такая структура обеспечивает четкое разделение ответственности. Если разработчик меняет логику обработки платежей, он работает только в папке `paths/Commerce/Payments`, минимизируя риск задеть другие части API.

### 2.2 Механика разрешения ссылок ($ref)

При работе с модульной структурой корректное использование `$ref` является главным техническим вызовом. Ссылки в OpenAPI разрешаются относительно текущего файла, а не корня проекта.²⁰

#### Правила навигации по ссылкам:

**Локальные ссылки (внутри одного файла):** Используются редко в модульном подходе, но синтаксис стандартный: `$ref: '#/components/schemas/User'`.

**Относительные ссылки (между файлами):** Это основа модульности. Если вы находитесь в файле `paths/Identity/Users/GetUser.yaml` и хотите сослаться на схему `User.yaml` в `components/schemas/Identity/`, путь должен быть следующим:

```yaml
# Файл: paths/Identity/Users/GetUser.yaml
responses:
  '200':
    content:
      application/json:
        schema:
          $ref: '../../../components/schemas/Identity/User.yaml'
```

Здесь `../../../` означает «подняться на три уровня вверх» (из Users → Identity → paths → root), чтобы затем зайти в `components`.²¹

**Ссылки на фрагменты внешних файлов:** Можно ссылаться не на весь файл целиком, а на конкретный объект внутри него, используя якорь `#`:

```yaml
$ref: '../common_definitions.yaml#/components/schemas/ErrorModel'
```

**Лучшая практика:** Старайтесь ссылаться на целые файлы (один файл = одна схема). Это упрощает чтение и поддержку, так как не требует поиска внутреннего якоря внутри длинного YAML-файла.¹²

### 2.3 Корневой файл (openapi.yaml) как маршрутизатор

Корневой файл собирает разрозненные модули в единое целое. Он не должен содержать детальных описаний операций. Его задача — определить скелет API и глобальные настройки навигации.

#### Пример идеального openapi.yaml для Redocly и OpenAPI 3.1:

```yaml
openapi: 3.1.0
info:
  title: Enterprise Modular API
  version: 1.2.0
  description: |
    # Документация API платформы
    Это пример модульной документации, собранной из отдельных YAML файлов.
    Мы используем **OpenAPI 3.1** для точной валидации типов.
  contact:
    name: API Support Team
    email: support@example.com
  license:
    name: Apache 2.0
    url: https://www.apache.org/licenses/LICENSE-2.0.html

servers:
  - url: https://api.example.com/v1
    description: Production Server
  - url: https://staging.api.example.com/v1
    description: Staging Environment

# Глобальная навигация через расширение Redocly
x-tagGroups:
  - name: Управление Доступом
    tags:
      - Пользователи
      - Аутентификация
  - name: Финансы и Платежи
    tags:
      - Заказы
      - Платежи
  - name: Аналитика
    tags:
      - Отчеты
      - Аудит

paths:
  # Домен Identity
  /users:
    $ref: './paths/Identity/Users/ListUsers.yaml'
  /users/{id}:
    $ref: './paths/Identity/Users/GetUser.yaml'

  # Домен Commerce
  /payments:
    $ref: './paths/Commerce/Payments/ProcessPayment.yaml'

  # Домен Reporting
  /reports/financial/annual:
    $ref: './paths/Reporting/Financial/AnnualReport.yaml'

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
```

В этом файле отчетливо видна роль `x-tagGroups`. Без этого расширения теги «Пользователи», «Платежи» и «Отчеты» отображались бы плоским списком. Группировка создает двухуровневую навигацию в боковой панели Redocly, что критически важно для удобства пользователя (UX).³

## Часть III: Особенности реализации в Reezonly Space (Custom Build)

В нашем проекте, помимо стандартного модульного подхода, используется **кастомный скрипт сборки** (`tools/build.js`). Это сделано для того, чтобы иметь возможность склеивать несколько крупных модульных файлов (`users.yaml`, `groups.yaml`) в один итоговый, при этом **сохраняя ссылки ($ref)** для корректного линтинга и чистоты кода.

### 3.1 Проблема "Dereferencing" и "Unused Components"

Стандартные парсеры (как `@apidevtools/swagger-parser`) по умолчанию "разворачивают" (dereference) все ссылки, превращая `$ref` в инлайн-копии объектов. Это приводит к двум проблемам:
1.  Итоговый файл становится огромным.
2.  Линтеры (Redocly) начинают жаловаться на "unused components", так как видят копии кода, а не ссылки на раздел `components`.

### 3.2 Решение: Отказ от дереференсинга при сборке

Мы модифицировали `tools/build.js`, отключив `SwaggerParser.dereference(completeSpec)` перед сохранением. Теперь скрипт:
1.  Загружает модули как есть (через `yaml.load`).
2.  Склеивает их в один объект.
3.  Нормализует пути ссылок (переписывает относительные пути в абсолютные `#/...`).
4.  Сохраняет результат **с сохранением ссылок** (`noRefs: false`).

Это позволяет нам:
*   Держать исходники в удобных модулях (`users.yaml`, `groups.yaml`).
*   Получать компактный `space-platform-api.yaml`.
*   Использовать всю мощь линтера Redocly, который теперь корректно видит связи между методами и компонентами.

---

## Часть IV: Конфигурация Redocly (redocly.yaml)

Файл `redocly.yaml` является центром управления тем, как ваша документация будет выглядеть и валидироваться. Для «наилучшего» результата необходимо использовать его возможности по максимуму, настраивая тему, правила линтинга и параметры отображения.¹⁸

### 4.1 Структура конфигурационного файла

Рекомендуется создать `redocly.yaml` в корне проекта. Этот файл управляет как поведением CLI (линтинг), так и рендерингом (theme).

```yaml
# redocly.yaml
apis:
  main:
    root: ./openapi.yaml  # Указание на точку входа

lint:
  extends:
    - recommended-strict  # Использование строгого набора правил [1]
  rules:
    # Кастомные правила для поддержания качества
    operation-description: error     # Требовать описание у каждого метода
    operation-summary: error         # Требовать краткую сводку
    no-ambiguous-paths: error        # Запрет на неоднозначные пути
    tags-alphabetical: warn          # Сортировка тегов

theme:
  openapi:
    # Настройки макета
    layout: three-panel              # Трехпанельный режим (лучший для чтения) 
    htmlTemplate:./docs/index.html  # Кастомный HTML шаблон (для header/footer)
    
    # Цветовая схема (Branding)
    theme:
      colors:
        primary:
          main: '#2f5bb7'            # Основной цвет бренда
        success:
          main: '#00c853'
        http:
          get: '#61affe'
          post: '#49cc90'
          put: '#fca130'
          delete: '#f93e3e'
      
      typography:
        fontFamily: 'Roboto, sans-serif'
        headings:
          fontFamily: 'Montserrat, sans-serif'
          fontWeight: 700
        code:
          fontFamily: 'Fira Code, monospace'

      sidebar:
        width: 280px
        backgroundColor: '#fafafa'
        textColor: '#333333'
        activeTextColor: '#2f5bb7'

    # Функциональные переключатели (Feature Toggles) [24]
    showExtensions: false            # Скрыть x- поля из финальной документации
    hideDownloadButton: true         # Убрать кнопку скачивания YAML (для чистоты UI)
    requiredPropsFirst: true         # Показывать обязательные поля схемы сверху (UX)
    simpleOneOfTypeLabel: true       # Упрощенный лейбл для oneOf
    jsonSamplesExpandLevel: 2        # Уровень раскрытия JSON примеров по умолчанию
    hideSingleRequestSampleTab: true # Если пример один, скрывать вкладку выбора языка
    
    # Генерация примеры кода
    generateCodeSamples:
      languages:
        - lang: curl
          label: cURL
        - lang: JavaScript
          label: Node.js
        - lang: Python
          label: Python
```

### 4.2 Обоснование ключевых настроек

**`layout: three-panel`:** Это стандарт де-факто для качественной API документации (в стиле Stripe). Левая панель — навигация, центральная — описание и параметры, правая — примеры запросов/ответов и код. Это позволяет пользователю видеть контекст и примеры одновременно, не прокручивая страницу вверх-вниз.¹⁴

**`requiredPropsFirst: true`:** Это важная UX-опция. В больших объектах (схемах) обязательные поля могут затеряться среди десятков необязательных. Данная настройка принудительно поднимает их наверх таблицы параметров.

**`jsonSamplesExpandLevel: 2`:** Если установить значение `all`, то огромные JSON-ответы развернутся полностью, загромождая экран. Значение 2 позволяет пользователю самому углубляться в структуру по мере необходимости.

---

## Часть V: Глубокая проработка методов (Case Studies)

В данном разделе мы приведем полный код для трех запрошенных методов из разных доменов, демонстрируя использование вложенности, описаний групп и полей согласно документации Redocly.

### 5.1 Метод 1: Домен «Identity» (Получение профиля пользователя)

**Файл:** `paths/Identity/Users/GetUser.yaml`

Этот метод демонстрирует классический GET-запрос с использованием параметров пути и переиспользованием схем ответов. Обратите внимание на использование Markdown в описании и кастомных примеров кода.

```yaml
get:
  summary: Получение детального профиля пользователя
  operationId: getUserProfile
  tags:
    - Пользователи
  description: |
    Возвращает полную информацию о пользователе по его уникальному идентификатору (UUID).
    
    :::info Права доступа
    Для выполнения этого запроса необходим скоуп `users:read` или права администратора.
    Пользователь всегда имеет доступ к своему собственному профилю.
    :::
    
    Ответ включает в себя:
    * Основные данные (имя, email)
    * Статус верификации
    * Дату последней активности
  
  externalDocs:
    description: Подробнее о модели прав доступа
    url: https://docs.example.com/guides/permissions

  parameters:
    - name: id
      in: path
      required: true
      description: Уникальный идентификатор пользователя (UUID v4).
      schema:
        type: string
        format: uuid
        example: "123e4567-e89b-12d3-a456-426614174000"

  responses:
    '200':
      description: Успешное получение профиля.
      content:
        application/json:
          schema:
            $ref: '../../../components/schemas/Identity/UserProfile.yaml'
          examples:
            ActiveUser:
              summary: Пример активного пользователя
              value:
                id: "123e4567-e89b-12d3-a456-426614174000"
                email: "alex@example.com"
                status: "active"
                last_login: "2023-10-25T14:30:00Z"
    '404':
      $ref: '../../../components/responses/NotFound.yaml'
    '401':
      $ref: '../../../components/responses/Unauthorized.yaml'

  # Вендорное расширение: Кастомные примеры кода [4, 15, 25]
  x-codeSamples:
    - lang: Python
      label: Python SDK
      source: |
        import my_api_sdk
        
        client = my_api_sdk.Client(token="YOUR_TOKEN")
        user = client.users.get("123e4567-e89b-12d3-a456-426614174000")
        print(f"User email: {user.email}")
    - lang: JavaScript
      source: |
        const user = await client.users.get('123e4567-e89b-12d3-a456-426614174000');
        console.log(user);
```

#### Анализ:

Использование адмонишенов (`:::info`) позволяет выделить важную информацию визуально. Redocly поддерживает этот расширенный Markdown.²⁶

Поле `x-codeSamples` позволяет предоставить идиоматический код, используя SDK компании, вместо сырого cURL, который генерируется автоматически. Это значительно повышает DX.

### 5.2 Метод 2: Домен «Commerce» (Создание платежа с полиморфизмом)

**Файл:** `paths/Commerce/Payments/ProcessPayment.yaml`

Этот метод демонстрирует мощь OpenAPI 3.1 и поддержку `oneOf` в Redocly. Мы создаем платеж, который может быть либо картой (CreditCard), либо через PayPal. Использование дискриминатора позволяет Redocly генерировать интерфейс с выпадающим списком для выбора типа тела запроса.¹⁰

```yaml
post:
  summary: Инициализация платежной транзакции
  operationId: processPayment
  tags:
    - Платежи
  description: |
    Создает новую транзакцию. Тело запроса является **полиморфным**: структура данных зависит от выбранного метода оплаты (`method`).
    
    Поддерживаемые методы:
    1. **Credit Card** - прямая оплата картой.
    2. **PayPal** - оплата через токен платежной системы.
  
  requestBody:
    required: true
    description: Данные для проведения платежа. Выберите тип схемы ниже.
    content:
      application/json:
        schema:
          oneOf:
            - $ref: '../../../components/schemas/Commerce/PaymentMethods/CreditCard.yaml'
            - $ref: '../../../components/schemas/Commerce/PaymentMethods/PayPal.yaml'
          discriminator:
            propertyName: method
            mapping:
              credit_card: '#/components/schemas/Commerce/PaymentMethods/CreditCard'
              paypal: '#/components/schemas/Commerce/PaymentMethods/PayPal'

  responses:
    '201':
      description: Платеж успешно создан и находится в обработке.
      content:
        application/json:
          schema:
            $ref: '../../../components/schemas/Commerce/Transaction.yaml'
    '400':
      description: Ошибка валидации данных (неверный номер карты или токен).
      content:
        application/json:
          schema:
            $ref: '../../../components/schemas/Shared/Error.yaml'
```

#### Схемы для полиморфизма (Components):

Для корректной работы дискриминатора, схемы должны содержать поле, указанное в `propertyName` (в данном случае `method`), как обязательное и с фиксированным значением (`const`).

**Файл:** `components/schemas/Commerce/PaymentMethods/CreditCard.yaml`

```yaml
type: object
title: Оплата картой
required:
  - method
  - pan
  - cvv
properties:
  method:
    type: string
    const: credit_card  # Ключ для дискриминатора
    description: Тип метода оплаты
  pan:
    type: string
    pattern: '^[0-9]{16}$'
    description: Номер карты
  cvv:
    type: string
    pattern: '^[0-9]{3,4}$'
```

**Файл:** `components/schemas/Commerce/PaymentMethods/PayPal.yaml`

```yaml
type: object
title: Оплата PayPal
required:
  - method
  - paypal_token
properties:
  method:
    type: string
    const: paypal       # Ключ для дискриминатора
  paypal_token:
    type: string
    description: Токен, полученный после авторизации пользователя в PayPal.
```

#### Анализ:

Redocly автоматически отрисует «кнопки» или выпадающий список для переключения между Credit Card и PayPal в документации.

Поле `title` в схемах используется для подписи этих кнопок, что делает интерфейс дружелюбным.

### 5.3 Метод 3: Домен «Reporting» (Сложный GET с вложенностью)

**Файл:** `paths/Reporting/Financial/AnnualReport.yaml`

Этот метод демонстрирует работу с глубокой иерархией URL и сложными параметрами запроса (query parameters).

```yaml
get:
  summary: Выгрузка годового финансового отчета
  operationId: getAnnualReport
  tags:
    - Отчеты
  # Используем x-displayName для изменения имени тега в боковом меню, если требуется
  # x-displayName: "Финансовая отчетность" [7]
  
  description: |
    Генерирует отчет за указанный фискальный год.
    
    > **Внимание:** Генерация может занимать до 60 секунд. Рекомендуется использовать вебхуки для уведомления о готовности, если отчет слишком большой.
  
  parameters:
    - name: year
      in: query
      required: true
      schema:
        type: integer
        minimum: 2015
        maximum: 2030
      description: Фискальный год (YYYY).
      
    - name: format
      in: query
      schema:
        type: string
        enum: [pdf, xlsx, csv]
        default: pdf
      description: Формат выходного файла.
      
    - name: include_audit_logs
      in: query
      schema:
        type: boolean
        default: false
      description: Включить ли в отчет журнал аудита изменений.

  responses:
    '200':
      description: Файл отчета.
      content:
        application/pdf:
          schema:
            type: string
            format: binary
        application/vnd.openxmlformats-officedocument.spreadsheetml.sheet:
          schema:
            type: string
            format: binary
```

---

## Часть VI: Внешние файлы и Markdown (Best Practices)

Для достижения полноты информации и модульности, Redocly позволяет выносить не только схемы, но и примеры кода, и даже описания (`description`) во внешние файлы.

### 6.1 Импорт Markdown описаний

Вместо того чтобы писать огромные блоки текста внутри YAML, лучше вынести их в файлы `.md`. Это позволяет использовать привычные редакторы Markdown и облегчает проверку орфографии.

```yaml
# Внутри определения метода
description:
  $ref: '../../docs/descriptions/users/get_user_intro.md'
```

Redocly поддерживает инъекцию Markdown-файлов через `$ref`.²⁷ Это особенно полезно для разделов «Введение», «Аутентификация» или сложных инструкций по расчету подписей.

### 6.2 Внешние примеры кода (x-codeSamples)

Для больших примеров кода вставка их прямо в YAML делает файл нечитаемым. Используйте `$ref` для загрузки кода из реальных файлов исходного кода, которые могут даже тестироваться вашей CI-системой.

```yaml
x-codeSamples:
  - lang: Python
    source:
      $ref: '../../../code_samples/python/users/get_user.py'
  - lang: Java
    source:
      $ref: '../../../code_samples/java/users/GetUser.java'
```

Этот подход гарантирует, что примеры в документации всегда актуальны и синтаксически верны.¹⁵

---

## Часть VII: Линтинг и контроль качества (CI/CD)

Создание документации — это половина дела. Вторая половина — гарантировать, что она соответствует стандартам и не ломается при изменениях. Redocly CLI предоставляет мощный линтер.

### 7.1 Настройка правил линтинга

В файле `redocly.yaml` необходимо прописать правила, которые будут блокировать коммиты с некачественной документацией.

```yaml
lint:
  extends:
    - recommended-strict
  rules:
    # Обязательное наличие описаний
    operation-description: error
    # Обязательное наличие contact info
    info-contact: error
    # Запрет на использование параметров в пути без их описания
    path-params-defined: error
    # Единообразие тегов (kebab-case или Title Case)
    tags-alphabetical: warn
```

Запуск проверки осуществляется командой `redocly lint openapi.yaml`. Это должно быть обязательным шагом (pipeline step) в вашем CI/CD процессе перед сборкой документации.¹

---

## Заключение и выводы

Построение «наилучшей» документации API с использованием Redocly и OpenAPI 3.1 требует системного подхода, выходящего за рамки простого написания YAML-файлов.

- **Модульность** — это фундамент. Используйте вложенную структуру папок (`paths/Domain/Resource/action.yaml`) для масштабируемости.
- **OpenAPI 3.1** — это точность. Используйте `oneOf` с дискриминаторами и новые типы массивов для точного описания данных.
- **Redocly Configuration** — это UX. Настройте `x-tagGroups` для навигации, `x-codeSamples` для полезности и тему для брендинга.
- **Линтинг** — это надежность. Автоматизируйте проверку ссылок и стилистики.

Реализация описанных выше практик позволит трансформировать вашу документацию из статического справочника в интерактивный портал разработчика, значительно снижая барьер входа для интеграторов и нагрузку на службу поддержки. Использование модульной архитектуры обеспечит возможность безболезненного роста API на годы вперед.¹