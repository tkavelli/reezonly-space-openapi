import { evaluateRuntimeExpressionPayload } from '../runtime-expressions/index.js';
import { getSecurityParameter } from '../context-parser/get-security-parameters.js';
import { validateXSecurityParameters } from './validate-x-security-parameters.js';
import { resolveSecurityScheme } from './resolve-security-scheme.js';
export function resolveXSecurityParameters({ ctx, runtimeContext, step, operation, workflowLevelXSecurityParameters, }) {
    const stepXSecurity = step['x-security'];
    const workflowLevelXSecurity = workflowLevelXSecurityParameters;
    const securities = [...(workflowLevelXSecurity || []), ...(stepXSecurity || [])];
    const parameters = [];
    for (const security of securities) {
        const scheme = resolveSecurityScheme({
            ctx,
            security,
            operation,
        });
        if ('schemeName' in security && !scheme) {
            throw new Error(`Security scheme "${security.schemeName}" not found`);
        }
        if (!scheme) {
            continue;
        }
        const values = Object.fromEntries(Object.entries(security?.values ?? {}).map(([key, value]) => {
            const evaluatedValue = evaluateRuntimeExpressionPayload({
                payload: value,
                context: runtimeContext,
                logger: ctx.options.logger,
            });
            if (security.values) {
                security.values[key] = evaluatedValue;
            }
            return [key, evaluatedValue];
        }));
        const resolvedSecurity = validateXSecurityParameters({ scheme, values });
        const param = getSecurityParameter(resolvedSecurity, ctx);
        if (param) {
            parameters.push(param);
        }
    }
    return parameters;
}
//# sourceMappingURL=resolve-x-security-parameters.js.map